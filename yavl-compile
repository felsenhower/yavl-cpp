#!/usr/bin/env python3

import sys
import argparse
from dataclasses import dataclass
from typing import Any, TextIO
import subprocess
import yaml
import os
import importlib.util

sys.path.append(os.path.dirname(os.path.realpath(__file__)) + "/src")

from yavl import CompilerOptions, CodeGenerator


def get_options() -> CompilerOptions:
    parser = argparse.ArgumentParser(
        description="Generate a C/C++ HEADER file from a YAVL SPEC.", allow_abbrev=False
    )
    parser.add_argument(
        "--no-validate-spec",
        help="Don't validate the spec before compiling (compiling may fail unexpectedly).",
        action="store_true",
    )
    parser.add_argument(
        "--no-emit-declarations",
        help="Don't emit type declarations.",
        action="store_true",
    )
    parser.add_argument(
        "--no-emit-readers",
        help="Don't emit code to convert from YAML to generated types.",
        action="store_true",
    )
    parser.add_argument(
        "--no-emit-writers",
        help="Don't emit code to convert from generated types to YAML.",
        action="store_true",
    )
    parser.add_argument(
        "--no-emit-validator",
        help="Don't emit code to validate a YAML document.",
        action="store_true",
    )
    parser.add_argument(
        "--no-emit-databindings",
        help="Shorthand for --no-emit-readers --no-emit-writers --no-emit-validator.",
        action="store_true",
    )
    parser.add_argument(
        "spec_file",
        metavar="<spec.yaml>",
        type=argparse.FileType("r", encoding="UTF-8"),
        help="The YAVL spec to compile.",
    )
    parser.add_argument(
        "header_file",
        metavar="<header.h>",
        type=argparse.FileType("w", encoding="UTF-8"),
        help="The target header file.",
    )
    args = parser.parse_args()
    options = CompilerOptions(args.spec_file, args.header_file)
    options.validate_spec = not args.no_validate_spec
    options.emit_declarations = not args.no_emit_declarations
    if args.no_emit_databindings:
        options.emit_readers = False
        options.emit_writers = False
        options.emit_validator = False
    else:
        options.emit_readers = not args.no_emit_readers
        options.emit_writers = not args.no_emit_writers
        options.emit_validator = not args.no_emit_validator
    return options


def validate_spec(filename: str):
    try:
        cwd = os.path.dirname(os.path.realpath(__file__))
        pipe = subprocess.run(
            ["./yavl-validate-spec", filename],
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        if pipe.returncode != 0:
            sys.exit(
                'Error during validation of spec "{}":\n{}'.format(
                    filename, pipe.stderr.decode()
                )
            )
    except FileNotFoundError as e:
        sys.exit('Error: yavl-validate-spec was not found. Please run "make".')
    except PermissionError:
        sys.exit("Error: yavl-validate-spec is not executable.")


def main() -> None:
    options = get_options()
    try:
        spec = yaml.safe_load(options.spec_filestream)
        if options.validate_spec:
            validate_spec(options.spec_filestream.name)
        generator = None
        if "CustomCodeGenerator" in spec:
            module_path, class_name = spec["CustomCodeGenerator"]
            module_spec = importlib.util.spec_from_file_location(
                "CustomCodeGenerator", module_path
            )
            custom_code_generator_module = importlib.util.module_from_spec(module_spec)
            sys.modules["CustomCodeGenerator"] = custom_code_generator_module
            module_spec.loader.exec_module(custom_code_generator_module)
            klass = getattr(custom_code_generator_module, class_name)
            generator = klass(spec, options)
        else:
            generator = CodeGenerator(spec, options)
        generator.emit_header()
    except yaml.YAMLError as e:
        sys.exit(
            'Error: The file "{}" doesn\'t seem to be valid YAML:\n{}'.format(
                options.spec_filestream.name, e
            )
        )


if __name__ == "__main__":
    main()
